<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Pong Height Check (Web)</title>
  <style>
    html,body { margin:0; background:#111; color:#eee; font-family:system-ui,sans-serif; height:100%; }
    #wrap { position:relative; width:100vw; height:100vh; overflow:hidden; }
    /* Layers: hidden video < canvas (image) < overlay (UI) < buttons */
    #video   { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; opacity:0; }
    #canvas  { position:absolute; inset:0; width:100%; height:100%; }
    #overlay { position:absolute; inset:0; width:100%; height:100%; pointer-events:auto; }
    #ui { position:fixed; left:8px; bottom:8px; z-index:5; background:#0008; padding:8px 10px; border-radius:8px; font-size:14px; }
    .btn { background:#2e7; border:0; padding:6px 10px; border-radius:6px; color:#000; cursor:pointer; margin-right:6px; }
    .tag { opacity:.85; margin-left:6px; }
    #status { position:fixed; left:8px; top:8px; z-index:6; background:#f66; color:#000; font-weight:600; padding:6px 10px; border-radius:8px; display:none; }
  </style>
</head>
<body>
  <div id="wrap">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
    <canvas id="overlay"></canvas>
  </div>

  <div id="status"></div>

  <div id="ui">
    <button id="start" class="btn">Start camera</button>
    <button id="maskBtn" class="btn">Toggle mask</button>
    <span class="tag" id="hsvTag"></span>
  </div>

  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  // ---- HSV thresholds (load from localStorage if present) ----
  function loadHSV() {
    try {
      const L = JSON.parse(localStorage.getItem('pong_lower'));
      const U = JSON.parse(localStorage.getItem('pong_upper'));
      if (Array.isArray(L) && L.length===3 && Array.isArray(U) && U.length===3) return [L,U];
    } catch {}
    // default (orange-ish); you'll long-press to retune for blue/other colors
    return [[5,120,200],[25,255,255]];
  }
  let [LOWER, UPPER] = loadHSV();

  const MIN_AREA = 120;
  const TRAIL_LEN = 20;
  const NEEDED_FRAMES_ABOVE = 3;
  let COOLDOWN_FRAMES = 7;

  // ---- DOM ----
  const video   = document.getElementById('video');
  const canvas  = document.getElementById('canvas');
  const overlay = document.getElementById('overlay');
  const ctxUI   = overlay.getContext('2d');
  const startBtn= document.getElementById('start');
  const maskBtn = document.getElementById('maskBtn');
  const hsvTag  = document.getElementById('hsvTag');
  const statusEl= document.getElementById('status');

  function refreshHSVTag(){
    hsvTag.textContent = `H[${LOWER[0]}-${UPPER[0]}] S[${LOWER[1]}-${UPPER[1]}] V[${LOWER[2]}-${UPPER[2]}]`;
  }
  function setStatus(msg){ statusEl.textContent=msg||""; statusEl.style.display=msg?"inline-block":"none"; }
  refreshHSVTag();

  // ---- State ----
  let showMask = false;
  let lineY = null;
  let aboveStreak = 0;
  let legalCooldown = 0;
  const trail = Array(TRAIL_LEN).fill(null);
  let validDetectStreak = 0;

  // Mats (realloc on size change)
  let W=0, H=0;
  let src=null, frame=null, hsv=null, mask=null, blur=null, opened=null, kernel=null;

  // Offscreen canvas to grab <video> frames (avoids cv.VideoCapture issues on iOS)
  const grab = document.createElement('canvas');
  const gtx  = grab.getContext('2d', { willReadFrequently: true });

  // Pending color pick (set by long-press)
  let pendingPick = null;

  // Helpers
  const clamp = (v, lo, hi)=>Math.max(lo, Math.min(hi, v));
  const median = arr => { const a=[...arr].sort((x,y)=>x-y); const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2; };

  // Tap / long-press handling
  let pressTimer = null, pressXY = null;
  function onPointerDown(e){
    const rect = overlay.getBoundingClientRect();
    const cx = (e.clientX ?? (e.touches && e.touches[0].clientX)) - rect.left;
    const cy = (e.clientY ?? (e.touches && e.touches[0].clientY)) - rect.top;
    // Convert to canvas coordinates
    const x = Math.round(cx * (overlay.width / rect.width));
    const y = Math.round(cy * (overlay.height / rect.height));
    pressXY = {x,y};
    pressTimer = setTimeout(()=>{ pendingPick = pressXY; setStatus("Picked color… updating HSV"); }, 450); // long-press
  }
  function onPointerUp(){
    if (pressTimer){
      clearTimeout(pressTimer);
      pressTimer = null;
      if (!pendingPick && pressXY){ // it was a tap → set/move line
        lineY = pressXY.y;
      }
    }
  }
  overlay.addEventListener('pointerdown', onPointerDown);
  overlay.addEventListener('pointerup', onPointerUp);
  overlay.addEventListener('touchstart', onPointerDown, {passive:true});
  overlay.addEventListener('touchend', onPointerUp, {passive:true});

  // Camera start
  startBtn.onclick = async () => {
    startBtn.disabled = true;
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
      video.srcObject = s;
      setStatus('Camera started — waiting for OpenCV… (long-press the ball to auto-tune)');
    } catch (e) {
      setStatus('Camera error: ' + e);
      startBtn.disabled = false;
    }
  };
  maskBtn.onclick = () => { showMask = !showMask; };

  // Ensure mats & canvases match the current video size
  function ensureSize() {
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return false;
    if (vw === W && vh === H && src) return true;

    [src, frame, hsv, mask, blur, opened, kernel].forEach(m => { try { m && m.delete(); } catch {} });

    W = vw; H = vh;
    canvas.width = overlay.width = W;
    canvas.height = overlay.height = H;
    grab.width = W; grab.height = H;

    src    = new cv.Mat(H, W, cv.CV_8UC4);
    frame  = new cv.Mat(H, W, cv.CV_8UC3);
    hsv    = new cv.Mat();
    mask   = new cv.Mat();
    blur   = new cv.Mat();
    opened = new cv.Mat();
    kernel = cv.Mat.ones(5, 5, cv.CV_8U);
    return true;
  }

  // Wait for both camera and OpenCV to be ready
  let opencvReady = false, streamReady = false;
  cv.onRuntimeInitialized = () => { opencvReady = true; setStatus('OpenCV ready — start the camera.'); maybeStart(); };
  video.addEventListener('loadedmetadata', () => { streamReady = true; maybeStart(); });
  window.addEventListener('orientationchange', () => { setTimeout(ensureSize, 300); });

  function maybeStart(){
    if (!opencvReady || !streamReady) return;
    if (!ensureSize()) return;
    setStatus('Running… tap = set line, long-press = pick color');
    loop();
  }

  function isValidBallContour(c) {
    const circle = cv.minEnclosingCircle(c);
    const x = circle.center.x, y = circle.center.y, r = circle.radius;
    if (r < 6 || r > 90) return [false, x, y, r];
    const area = cv.contourArea(c, false); if (area <= 1) return [false, x, y, r];
    const peri = cv.arcLength(c, true);    if (peri <= 1) return [false, x, y, r];

    const circularity = 4.0 * Math.PI * (area / (peri * peri));
    if (circularity < 0.70) return [false, x, y, r];

    const hull = new cv.Mat(); cv.convexHull(c, hull, false, true);
    const hullArea = cv.contourArea(hull, false); hull.delete();
    if (hullArea <= 0) return [false, x, y, r];
    const solidity = area / hullArea;
    if (solidity < 0.85) return [false, x, y, r];
    return [true, x, y, r];
  }

  function loop() {
    function tick() {
      try {
        if (!ensureSize()) { requestAnimationFrame(tick); return; }

        // Grab current frame
        gtx.drawImage(video, 0, 0, W, H);
        const imgData = gtx.getImageData(0, 0, W, H);
        src.data.set(imgData.data);  // RGBA

        // Process
        cv.cvtColor(src, frame, cv.COLOR_RGBA2BGR);
        cv.cvtColor(frame, hsv, cv.COLOR_BGR2HSV);

        // If user long-pressed, sample a small patch and set HSV
        if (pendingPick){
          const {x, y} = pendingPick;
          const r = 6; // sample radius
          const Hs=[], Ss=[], Vs=[];
          for (let dy=-r; dy<=r; dy++){
            const yy = clamp(y+dy, 0, H-1);
            for (let dx=-r; dx<=r; dx++){
              const xx = clamp(x+dx, 0, W-1);
              const idx = (yy*W + xx)*3;
              Hs.push(hsv.data[idx]);
              Ss.push(hsv.data[idx+1]);
              Vs.push(hsv.data[idx+2]);
            }
          }
          const h0 = median(Hs), s0 = median(Ss), v0 = median(Vs);
          const huePad = 12, svPad = 60;
          LOWER = [ clamp(h0 - huePad, 0, 179), clamp(s0 - svPad, 0, 255), clamp(v0 - svPad, 0, 255) ];
          UPPER = [ clamp(h0 + huePad, 0, 179), 255, 255 ];
          localStorage.setItem('pong_lower', JSON.stringify(LOWER));
          localStorage.setItem('pong_upper', JSON.stringify(UPPER));
          refreshHSVTag();
          setStatus(`HSV updated → H[${LOWER[0]}-${UPPER[0]}] S[${LOWER[1]}-255] V[${LOWER[2]}-255]`);
          pendingPick = null;
        }

        // Threshold & cleanup
        const lower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [LOWER[0], LOWER[1], LOWER[2], 0]);
        const upper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [UPPER[0], UPPER[1], UPPER[2], 255]);
        cv.inRange(hsv, lower, upper, mask);
        lower.delete(); upper.delete();

        cv.GaussianBlur(mask, blur, new cv.Size(9,9), 0);
        cv.morphologyEx(blur, opened, cv.MORPH_OPEN, kernel);

        // Find contours
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(opened, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let ballCenter = null;
        const idxs = [...Array(contours.size()).keys()];
        idxs.sort((a,b)=>cv.contourArea(contours.get(b)) - cv.contourArea(contours.get(a)));
        for (let i=0; i<Math.min(5, idxs.length); i++) {
          const c = contours.get(idxs[i]);
          if (cv.contourArea(c) < MIN_AREA) { c.delete(); continue; }
          const [ok, x, y, r] = isValidBallContour(c);
          if (!ok) { c.delete(); continue; }
          const M = cv.moments(c, false);
          if (M.m00 !== 0) ballCenter = { x: Math.round(M.m10/M.m00), y: Math.round(M.m01/M.m00) };
          c.delete(); break;
        }
        contours.delete(); hierarchy.delete();

        // Debounce (require 2 consecutive frames)
        if (ballCenter) validDetectStreak = Math.min(validDetectStreak+1, 2);
        else            validDetectStreak = 0;
        if (validDetectStreak < 2) ballCenter = null;

        // Draw frame or mask
        cv.imshow('canvas', showMask ? opened : frame);

        // Overlay
        ctxUI.clearRect(0,0,overlay.width,overlay.height);
        if (lineY !== null) {
          ctxUI.strokeStyle = 'yellow';
          ctxUI.lineWidth = 3;
          ctxUI.beginPath();
          ctxUI.moveTo(0, lineY);
          ctxUI.lineTo(overlay.width, lineY);
          ctxUI.stroke();
        }
        // Trail
        trail.push(ballCenter ? {x:ballCenter.x, y:ballCenter.y} : null);
        if (trail.length > TRAIL_LEN) trail.shift();
        ctxUI.strokeStyle = 'rgba(0,200,255,0.9)';
        ctxUI.lineWidth = 2;
        for (let i=1;i<trail.length;i++) {
          const a = trail[i-1], b = trail[i];
          if (a && b) { ctxUI.beginPath(); ctxUI.moveTo(a.x,a.y); ctxUI.lineTo(b.x,b.y); ctxUI.stroke(); }
        }
        // LEGAL
        if (lineY !== null && ballCenter) {
          if (ballCenter.y < lineY - 3) aboveStreak++; else aboveStreak = 0;
          if (aboveStreak >= NEEDED_FRAMES_ABOVE) { legalCooldown = COOLDOWN_FRAMES; aboveStreak = 0; }
        }
        if (legalCooldown > 0) {
          ctxUI.fillStyle = 'rgba(0,255,0,0.9)';
          ctxUI.font = 'bold 28px system-ui, sans-serif';
          ctxUI.fillText('LEGAL', 16, overlay.height - 16);
          legalCooldown--;
        }

        requestAnimationFrame(tick);
      } catch (e) {
        setStatus('Runtime error: ' + e);
      }
    }
    requestAnimationFrame(tick);
  }
  </script>
</body>
</html>
